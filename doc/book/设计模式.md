## 设计模式

```
主题：把不变的事物和变化的事物分离开来
定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案，设计模式就是给面向对象软件开发中的一些好的设计取个名字
作用：当合适的场景出现时，可以很快地找到某种模式作为解决方案
适用性：找出程序中变化的地方，并将变化封装起来，写出可复用和可维护性高的程序，不要误用和滥用
分辨模式的关键是意图而不是结构
```

#### 原型模式

```
通过克隆来创建一个一模一样的对象，提供了一种便捷的方式去创建某个类型的对象
JavaScript使用原型模式来搭建整个面向对象系统
```

#### 单例模式

```
保证一个类仅有一个实例，并提供一个访问它的全局访问点
用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象
```

#### 策略模式

```
定义一系列指向同一目标的业务规则，把它们各自封装成策略类或函数，使用时把请求委托给这些策略对象中间的某一个进行执行
可以避免多重条件选择语句，分离算法实现和调用，封装算法实现使其可复用
```

#### 代理模式

```
当发现不方便直接访问某个对象的时候，为对象提供一个替身对象，替身对象对客户请求做出一些处理之后，再把请求转交给本体对象
代理和本体接口保持一致，代理和本体将来可以被替换使用
单一职责原则：就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个
保护代理：判断客户是否满足访问条件
虚拟代理：把一些方法延迟到真正需要它的时候才去执行
```

#### 迭代器模式

```
提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示
内部迭代器：内部已经定义好了迭代规则，只需一次初始调用
外部迭代器：显式地请求迭代下一个元素
```

#### 发布—订阅（观察者）模式

```
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知
作用：可以广泛应用于异步编程中，这是一种替代传递回调函数的方案；可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口
```

#### 命令模式

```
一个执行某些特定事情的指令，使请求发送者和请求接收者能够消除彼此之间的耦合关系，支持撤销、排序
```

#### 组合模式

```
用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的
表示树形结构
利用对象多态性统一对待组合对象和单个对象
```

#### 模板方法模式

```
一种只需使用继承就可以实现的非常简单的模式，javascript里可以不用继承就能实现
由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法
```

#### 享元模式

```
用于性能优化，运用共享技术可以用相对较少的共享对象取代大量相似对象
一种用时间换空间的优化模式
内部状态储存在共享对象的内部，外部状态储存在共享对象的外部
```

#### 职责链模式

```
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系
职责链中的节点数量和顺序是可以自由变化的
```

#### 中介者模式

```
解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可
如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码
```

#### 装饰者（包装器）模式

```
可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象
```

#### 状态模式

```
关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变
```

#### 适配器（包装器）模式

```
解决两个软件实体间的接口不兼容的问题
```

#### 外观模式

```
对客户屏蔽一组子系统的复杂性，对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现
```

#### 单一职责（SRP）原则

```
一个对象（方法）只做一件事情，应该仅有一个引起它变化的原因，把对象划分成较小的粒度
如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们
职责的变化轴线仅当它们确定会发生变化时才具有意义
违反SRP的情况：在方便性与稳定性之间要有一些取舍，对于api的维护者来说，会带来一些困难，但对于api的使用者来说，却简化了使用方法
```

#### 最少知识原则（迪米特法则）

```
一个软件实体应当尽可能少地与其他实体发生相互作用，尽量减少对象之间的交互
把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小
```

#### 开放-封闭原则

```
软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改
当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码
找出程序中将要发生变化的地方，然后把变化封装起来
在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。然后确保我们不会掉进同一个坑里
```

