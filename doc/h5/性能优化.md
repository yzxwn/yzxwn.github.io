## h5 性能优化

```
能节省网络时长多少均值，提升渲染时长均值，提升dom渲染的效率评估数据
针对可能的问题，再给出优化方案

从解决问题的角度去分析技术优化方案，首字节时间、白屏时间、可交互时间、完全加载时间

```

#### 为什么要进行性能优化

- 记录页面从加载资源解析资源以及渲染页面，执行脚本等一系列动作的综合表现
- 如今任何互联网产品首先重要的都是流量，流量最终会转换为商业价值。所以在互联网产品中，流量、转化率和留存率基本上是产品经理或者业务非常关注的几个因素，而性能则会直接影响到用户的转化和留存（在一定阶段之后影响较大，产品初期功能的因素占比更大）。所以换言之性能，其实是钱，我们关注和监测性能并非是为了数据而数据。产品的使用体验包含三大要素：产品功能、交互视觉、前端性能，而我们做性能优化的最终目的是提升前端性能，从而提升产品体验。

#### 前端性能指标

- 非视觉指标（体验优化的常规指标）
  - 首字节时间（用于衡量网络链路和服务器响应性能）
  - 白屏时间（firstPaint）
  - 可交互时间（interactive）
  - 完全加载时间（load）
- 视觉指标（衡量用户的感官性能）
  - First Content Paint：文档中内容元素（文本、图像、Canvas，或者 SVG）首次渲染的时间。测量在用户导航到您的页面后浏览器呈现第一段 DOM 内容所花费的时间。
  - First Meaningful Paint：浏览器有意义的内容的绘制时间，比如博客的博文主体绘制时间，它的统计在重大的布局变化之后，往往代表了用户所关心的首次渲染时间。
  - Speed Index: 浏览器出现可视内容的时间（通常出现在浏览器初次提交绘制指令之后），该指标捕获的是页面出现像素点的时间，它代表了我们页面在加载过程中视觉上的变化速度，其值越小代表感官性能越好。
  - First CPU idle：主线程初次空闲时间，意味着此时的用户交互可以被处理，比如 react 的第一次异步调度就可能出现在这里。
  - Time to Interactive：页面可以进行交互的时间，这个指标并不是指的最早的可交互时间，而是可流畅交互的时间。什么叫可交互：页面有可见内容渲染，可见渲染的内容已经注册事件，并且页面在 50 毫秒响应用户输入
  - Max Potential First Input Delay：用户可能体验到的最大无响应时间，具体的值就是最长的 task 执行时间。衡量的是从用户第一次与页面进行交互，到浏览器实际上能够开始处理事件处理程序的时间，响应这种互动。以用户为中心的度量负载响应能力的指标，因为它量化了用户在尝试与没有响应的页面交互时的体验。低的 FID 有助于确保页面可用。
  - Largest Contentful Paint：最大面积渲染，这个指标最具有代表性，所以会使用这个指标来作为重要的性能指标。原因：最大内容绘画（LCP）是衡量用户感知加载速度的重要因素，以用户为中心的度量标准，因为它标记了页面主要内容可能已加载时页面加载时间线中的时间点-快速的 LCP 有助于使用户确信页面有用
  - Cumulative Layout Shift：累积布局移位。页面内容的意外移动，通常是由于异步加载资源或将 DOM 元素动态添加到现有内容上方的页面而发生的。

#### Opportunities（可以优化的性能点）

- 推荐使用下一代图片格式化的技术，原因是 JPEG 2000、JPEG XR 和 WebP 等图像格式通常比 PNG 或 JPEG 提供更好的压缩，这意味着更快的下载速度和更少的数据消耗
- 减少阻塞渲染的资源加载，所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染，例如 CSS 文件（css 加载完成后，js 的下载不会阻塞渲染），可以给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。
- 提前和要拉取资源的源建立链接，在 link 标签使用 preconnect，dns-prefetch，dns-prefetch 等属性进行网络上的链接操作（eg：<link ref="preconnect" href="my.cdn.com">）
- 文本资源要压缩后传输如：gzip
- 响应式图片，使用合适尺寸的图片资源，比如 iOS 下系统会根据分辨率选择@2x 还是@3x 之类的图片
- 懒加载不在可视区域上的图片，在所有关键资源加载完成后，考虑延迟加载屏幕外和隐藏图像，以缩短交互时间
- 移除没有用到的 CSS 文件
- 避免多次重定向，重定向会降低您的页面加载速度
- 使用视频来代替 gif 图片的加载
- 避免引入第三方代码 or 文件
- 避免巨大的网络负载（官方说的很通俗，流量也是要钱的）
- 资源缓存，当浏览器请求资源时，提供资源的服务器可以告诉浏览器它应该暂时存储或缓存资源多长时间。对于对该资源的任何后续请求，浏览器将使用其本地副本，而不是从网络获取它。
- 避免大型的 DOM 结构（少于 1500 多个节点、深度不大于 32 个节点、父节点的子节点不超过 60 个）
- 减少请求数量和请求数据大小
- 压缩外部资源
- 对 JavaScript 进行分包
- 对各种外部资源进行懒加载
- 请求链路上的优化（缓存，cdn，http2 诸如此类）
- 减少 HTTP 请求次数，一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程，将多个小文件合并为一个大文件可以提高真正下载数据的时间占比
- 使用 HTTP2，相比 HTTP1.1 解析速度快、多路复用、首部压缩、可设置优先级、流量控制、支持服务器推送
- 使用服务端渲染，服务端返回 HTML 文件，客户端只需解析 HTML，首屏渲染快，SEO 好，但是配置麻烦，增加了服务器的计算压力。
- 静态资源使用 CDN，内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。
- 减少重绘重排，重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。
- 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

#### Diagonstics（现有代码存在的问题）

- 确保字体文件加载过程中，字体能够显示。可能很多人对这点干掉懵逼：如果我们的样式使用了第三方字体，在字典加载完成前浏览器会延迟渲染字体（Chrome 会延迟三秒），如果字体文件过大，下载时间过长网页内容就会空有架子没有文字
- 尽量减少主线程的任务，主线程的任务比我们想象的要多的多，我们能比较好优化点也只有：脚本执行/解析/编译；其余几项都与我们要输出的内容有关，所以能优化的比较有限。脚本的执行耗时最多，也是最好优化的，实际上我们在应用入口中常常初始化太多东西，为了方便后续同步使用这些资源。可以使用 webpack 对初始化脚本进行切割，用异步的方式使用这些脚本资源
- 定制合理的缓存策略，一般都是因为缓存时长太短
- DOM 太多了，会导致应用比较吃内存，layout 和 reflow 的性能消耗过高，这种问题主要从开发层面进行预防，比如 codereview

#### 总结

- 一个性能测试工具，并不能完全代表用户的真实体验
