## 备忘录


===========================================================================
* **程序员**：
    * 需要学习的是编程思想，而不是编程语言
    * 不做github的搬运工，要自己创造代码（使用自己开发的框架，而不是 api 的使用者）
    * 学习的毅力，推动团队进步，乐于分享
    * 一个真正有价值的程序员不仅需要自身工作能力强，还需要能帮助伙伴使团队增强工作能力
* **工作**：
    * 专注于技术的研究和能力的提升，与项目团队一起进步
    * 必须完成的事会有压力，想要完成的事才有动力
    * 兴趣支撑不起工作，责任感才能让人保持对工作的热情
    * 比起写，代码更多地是给人看的
* **公司**：
    * 有进步发展空间，在一个良好的工作环境中让人养成良好的工作习惯
    * 花时间和精力去培养公司员工的自身技术和工作能力
    * 对于过时代码或者临时应急的解决方案后期会有一些处理方案
    * 进行code review，除了监控进度，还要管理代码质量
* **特点**：
    * 做自己想做的事，做影响未来的事，好奇是知识的萌芽
    * 想奋斗是不服输，想安稳是输不起
    * (和开朗活泼的人相处，和别人讨论问题，一起解决问题是很开心的事)
* **离职**：
    * 推动发展新技术 量化收益
    * 不是我想离开那里，而是我想来这里
    * 我很享受那里的时光，但是我想寻求新的挑战
    * 不是为了生存，而是为了发展
    * 个人职业发展，大公司自带光环（优秀的技术沉淀和管理制度），小公司成长快

性别 工作经历合并 描述20不好 xx平台里的聊天室
不做架子工 修改组件库 路由懒加载 游戏预加载
不知道换成自己的理解 如果以后的工作有需要会很快的去深入学习 这是我的理解，你的更深层次理解？学习到了，其他的问题？

===========================================================================
* **web**：
    * **跨域**：
    ```
    同源："协议+域名+端口"三者相同
    为什么会有同源策略：一种安全策略，防止浏览器受到 XSS（恶意脚本注入）、CSFR（跨站请求伪造）等攻击
    限制内容：Cookie、LocalStorage、IndexedDB 等存储性内容，DOM 节点，AJAX 请求发送后，结果被浏览器拦截了
    允许跨域加载资源：img、link、script、iframe
    解决方案：
        jsonp：利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数（需要对方的服务器做支持、仅支持 get 方法、可能会遭受 XSS 攻击）
        cors：服务端设置 Access-Control-Allow-Origin
        postMessage：允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
        websocket：允许跨域通讯，浏览器与服务器的全双工通信
        node中间件：代理服务器，服务器向服务器请求就无需遵循同源策略
        nginx反向代理：反向代理服务器，支持所有浏览器，可以顺便修改 cookie 信息（最简单的跨域方式）
        iframe + window.name：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）
        iframe + location.hash：不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信
        iframe + document.domain：两个页面都通过 js 强制设置 document.domain 为基础主域（只能用于二级域名相同的情况下）
        proxy：webpack配置代理
    ```
    * **本地存储**：
    ```
    cookie（4KB）：服务端脚本可以读写存储在客户端的cookie值，（有效期：默认-浏览器进程关闭之前，max-age设置有效期时长秒，作用域：默认-同目录或其子目录，path指定路径前缀，domain指定域）
    Web存储（2.5MB-10MB）：localStorage（有效期：永久性，作用域：同浏览器同源文档共享）、sessionStorage（有效期：浏览器页面关闭之前-可恢复，作用域：顶级窗口共享）
    HTML5-离线缓存（Application Cache）：解析缓存清单文件manifest，只从服务器下载更新过的资源，其他文件像cookie一样被存储下来
    Servers Work:更新Cache Storage、代理服务器拦截请求、非主线程、异步、https、postMessage与主窗口通信
    客户端数据库（IndexedDB）：对象数据库（同源页面共享）
    ```
    * **浏览器渲染原理**：
    ```
    1）处理 HTML 标记并构建 DOM 树：渲染阻塞，可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞
    2）处理 CSS 标记并构建 CSSOM 树：渲染阻塞，针对 script 标签设置并行加载（defer：延迟执行，async：立即执行）
    3）将 DOM 与 CSSOM 合并成一个渲染树
    4）根据渲染树来布局，以计算每个节点的几何信息
    5）将各个节点绘制到屏幕上
    --------------------------------------------------------
    请求数据到请求结束与服务器进行了几次交互
    可详细描述浏览器从输入URL到页面展现的详细过程
    浏览器解析HTML代码的原理，以及构建DOM树的流程
    浏览器如何解析CSS规则，并将其应用到DOM树上
    浏览器如何将解析好的带有样式的DOM树进行绘制
    浏览器回流与重绘的底层原理，引发原因，如何有效避免
    浏览器的垃圾回收机制，如何避免内存泄漏：标记清除、引用计数
    浏览器采用的缓存方案，如何选择和控制合适的缓存方案
    ```
    * **Ajax原生写法**：
    ```
    1）创建一个XMLHttpRequest对象：
        new XMLHttpRequest()
        IE6：new ActiveXObject("Microsoft.XMLHTTP")
    2）配置请求信息：请求的方式、路径、是否异步
        xhr.open("POST","/try/ajax/demo_post2.php",true)
        xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded")
    3）发送请求：
        xhr.send("fname=Zhou&lname=minghang")
    4）监听状态变化，执行相应回调函数：
        xhr.onreadystatechange=function()
        {
            if (xhr.readyState==4 && xhr.status==200){
                console.log(xhr.responseText);
            }else{
                 console.log('失败');
            }
        }
    GET与POST的区别：GET更快、有缓存、明文传输不安全、使用小文件、send不传参，POST没有数据量限制、必须传参
    ```
    * **项目工程**：
    ```
    理解npm、yarn依赖包管理的原理，两者的区别
    理解Babel、ESLint、webpack等工具在项目中承担的作用
    ESLint规则检测原理，常用的ESLint配置
    Babel的核心原理，可以自己编写一个Babel插件
    可以配置一种前端代码兼容方案，如Polyfill
    Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用
    可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins
    ```
* **CSS**：
    * **浏览器兼容性写法**：
    ```
    -webkit-：safari、chrome、
    -moz-：firefox
    -ms-：ie
    -o-：Opera
    ```
    * **盒模型**：
    ```
     ie 盒模型：box-sizing: border-box;
     标准 w3c 盒模型：box-sizing: content-box;
    ```
    * **CSS选择器**：
    ```
     伪类：link、visited、hover、active、focus、enabled、disabled、checked、selection、
     伪元素：first-line、first-letter、before、after
     CSS三大特性：
        层叠性：多种CSS样式的叠加
        继承性：子标签会继承上级标签的CSS样式属性（font、color、visibility、cursor）
        优先级：
            权重：权重相同时就近原则、声明靠后的优先级大
                规则：!important > 内联 > id > 类 > 标签 > 其他 > 继承
                效率：id > 类 > 标签 > 其他
    ```
    * **@import**：从其他样式表文件中导入样式
    * **@media**：媒体查询
    * **水平垂直居中**：
    ```
    父级flex
    父级flex +子级margin:auto
    absolute+transform
    父级table-cell+父级vertical-align: middle
    父级table +子级table-cell+子级vertical-align: middle
    ```
    * **BFC、IFC、FFC、GFC**：
    ```
    作用：
    1）阻止元素被浮动元素覆盖
    2）可以包含浮动元素（清除内部浮动）
    3）分属于不同的BFC时可以阻止margin重叠
    4）自适应两列布局
    BFC触发条件：
    1）html根元素
    2）float的值为left或right
    3）overflow的值为hidden或auto
    4）position的值为absolute、fixed
    5）display的值为inline-block、table-cell、table-caption
    ```
    * **css和js动画**：
    ```
    创建单独的 CSS 类来管理动画，使用 JavaScript 切换每个动画的开启和关闭
    CSS动画transforms 和 opacity在合成器线程上处理，任何动画触发绘制布局都会在主线程工作
    ```
    * **css 预处理器：Sass、Less**：是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。
    ```
    sass：
        用户多
        跳出嵌套：@at-root .child {}
        npm安装node-sass会失败
    less：
        编程能力弱，不直接支持对象，循环，判断等
    ```
    * **CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染**：
    ```
    oocss：分离结构和外观（增加可重复的设计单元，模块化规则），分离容器和内容（在任何位置都可以使用同一个样式）
    smacss：对样式的分类：基础（全局样式）、布局（实现不同的特色布局）、模块（可重复使用的一个单元）、状态（在特定状态下的布局或者模块的特殊化表现）、主题（针对特殊模块的主题设置）
    bem：块-元素-修饰符的思维去写样式。它不涉及具体的css结构，只是建议你如何命名css
    ```
    * **em、rem**：
    ```
    em：相对父级元素的字体大小
    rem：相对根元素的字体大小
    ```
    * **cssnext**：
    ```
    ```
* **HTML**：
    * **Web语义化**：
    ```
    使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义
    有利于 SEO
    ```
    * **简洁的html结构**：
    ```
    <!DOCTYPE HTML>
    <html lang="">
        <head>
            <meta charset="UTF-8">
            <title></title>
        </head>
        <body>
        </body>
    </html>
    ```
    * **html5**：
    ```
    audio、video、拖放（Drag 和 drop）、Canvas、支持内联 SVG、localStorage|sessionStorage、Web Worker（运行在后台的 JavaScript）
    ```
* **JavaScript**：
    * **基本数据类型**：number、string、boolean、object、null、undefined、symbol
    * **堆栈**：
    ```
    栈：空间小、大小固定，存储基本类型（Undefined、Null、Boolean、Number、String）
    堆：空间大、大小不固定，存储引用类型（Object、Array、Function）
    理解堆栈溢出和内存泄漏的原理，如何防止
        堆栈溢出：没有足够的内存空间供其使用
        内存泄漏：不再用到的内存，没有及时释放
        解决方案：引入闭包、引入计时器、尾调优化
        垃圾回收机制：引用计数、标记清除
        尽量不定义全局变量、释放不再用到的变量、用匿名自执行函数把全局变成局部、避免使用闭包
    ```
    * **判断数据类型**：
    ```
    typeof：可以测试出number、string、boolean、undefined、function，对于null、array、object均检测出为object
    instanceof：检查某个对象是不是另一个对象的实例。不能区别undefined和null，对于基本类型如果不是用new声明的也测试不出来，对于是使用new声明的类型，它还可以检测出多层继承关系
    constructor：undefined和null没有contructor属性，并且使用它是不安全的，因为contructor的指向是可以改变的
    Object.prototype.toString.call | toString.call：[object 数据类型]，不能检测非原生构造函数的构造函数名，toString全局方法可能被重写
    ```
    * **可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用**：
    ```
    转换形式：
        转换为原始值：
            ToPrimitive(需要转换的对象，期望转换为的原始数据类型number|string？)
            该对象为Date，则type被设置为string，否则，type被设置为number
            string先调用toString方法，number先调用valueOf方法
        转换为number：undefined->NaN null->+0、boolean->0|1、string->number|NaN、object->ToPrimitive
        转换为string：undefined->"undefined"、null->"null"、boolean->"true"|"false"、number->string|NaN、object->ToPrimitive
    +运算：进行ToPrimitive()操作，如果存在String，则对其进行ToString处理后进行拼接操作，其他的都进行ToNumber处理
    ==比较：如果存在对象，ToPrimitive() type为number进行转换，存在boolean，按照ToNumber将boolean转换为1或者0，如果x为string，y为number，x转成number进行比较
    if的判断语句里：转换成Boolean
    ```
    * **出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字**：
    ```
    精度丢失原因：二进制储存十进制的小数时不能完整的表示小数
    能够表示的最大数字Number.MAX_VALUE等于1.7976931348623157e+308,最大安全数字Number.MAX_SAFE_INTEGER等于9007199254740991
    避免精度丢失：
        计算小数时，先乘100或1000，变成整数再运算
        如果值超出了安全整数，有一个最新提案，BigInt大整数，它可以表示任意大小的整数，注意只能表示整数，而不受安全整数的限制
    ```
    * **字符串、数组、对象常用API、类数组转换成数组**：
    ```
    字符串：split indexOf replace slice substring substr match search
    对象：assign defineProperty keys freeze
    数组：join unshift shift push pop slice splice reverse sort
    类数组转换成数组：Array.prototype.slice.call()、Array.from()、扩展运算符（…）
    ```
    * **原型继承**：
    ```
    javascript面向对象实现：通过构造器函数创建实例对象来实现封装、通过原型和原型链来实现继承
    javascript在面向对象中函数的作用：功能函数（封装一块代码逻辑，便于重复调用，创建临时的内存空间）、构造器函数（创建实例对象，开辟新的内存空间）
    javascript的原型和原型链是什么：每个实例对象（ object ）都有一个私有属性（ _proto_）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象( _proto_) ，层层向上直到一个对象的原型对象为 null
        _proto_：object的原型
        prototype：function构造器的原型
        constructor：object的类别
    有几种方式可以实现继承，用原型实现继承有什么缺点，怎么解决：
        构造函数绑定：引用属性不共享，可以传参，可以多继承。不能继承父类原型属性和方法，无法实现函数复用
            function Son(name){
        　　　　Father.apply(this, arguments);
        　　　　this.name = name;
            }
        prototype模式：无法多继承，无法向父类传参，原型对象的引用属性被所有实例共享
            Son.prototype = new Father();
            Son.prototype.constructor = Son;
        直接继承prototype：省内存。父类和子类的原型指向了同一个对象，无法多继承
            Father.prototype.name = "123";
            Son.prototype = Father.prototype;
            Son.prototype.constructor = Son;
        利用空对象作为中介：省内存，父类和子类的原型不指向同一个对象
            var F = function(){};
            F.prototype = Father.prototype;
            Son.prototype = new F();
            Son.prototype.constructor = Son;
            Son.uber = Father.prototype;//实现继承的完备性，纯属备用性质
        拷贝继承：支持多继承。效率较低，无法获取父类不可枚举的方法
            for (var i in Father.prototype) {
    　　　　　　Son.prototype[i] = Father.prototype[i];
    　　　　 }
            Son.prototype.uber = Father.prototype;
        组合继承：调用了两次父类构造函数
            function Son(name){
        　　　　Father.apply(this, arguments);
        　　　　this.name = name;
            };
            Son.prototype = new Father();
            Son.prototype.constructor = Son;
        寄生组合式继承：
            function Son(name){
        　　　　Father.apply(this, arguments);
        　　　　this.name = name;
            };
            (function(){
                var F = function(){};
                F.prototype = Father.prototype;
                Son.prototype = new F();
                Son.prototype.constructor = Son;
                Son.uber = Father.prototype;
            })
        "非构造函数"继承：把子对象的prototype属性，指向父对象
            function object(o) {
        　　　　function F() {}
        　　　　F.prototype = o;
        　　　　return new F();
        　　}
    可以描述new一个对象的详细过程，手动实现一个new操作符
        var obj  = {};
        obj.__proto__ = F.prototype;
        F.call(obj);
    ```
    * **作用域闭包**：
    ```
    理解词法作用域和动态作用域：
        词法（静态）作用域：函数的作用域在函数定义的时候就决定了（javascript）
        动态作用域：函数的作用域是在函数调用的时候才决定的
    理解JavaScript的作用域和作用域链
    this：
        全局环境下（定时器，回调函数）this：window，严格模式undefined
        箭头函数的this：默认绑定外层this的值
        构造函数的this：每个构造函数在new之后都会返回一个对象，这个对象就是this
        总结this指向：谁调用它，this就指向谁
    闭包的实现原理和作用，可以列举几个开发中闭包的实际应用：
        闭包：有权访问另一个函数作用域中的变量的函数（内部函数被保存到外部）
        闭包是指的什么：通过函数调用，内外都持有数据的访问权，导致里面的块独立的内存空间永远存在且对外是封闭的，所以称为闭包
        作用：
            1.在外部获取函数体内部的局部变量
            2.维持函数中的局部变量在内存中不被销毁，可能造成内存泄漏
            3.避免全局冲突，防止污染，保证内部变量的安全
        实际应用：函数节流防抖、设计单例模式、设置私有变量
    ```
    * **模块化**：
    ```
    前端工程化：拆分模块、自动化工具（webpack、npm）、团队协作（git、svn）
    前端模块化：commonjs（nodejs的模块化规范：require|module.exports）、AMD/CMD/UMD（es6之前js的模块化规范）、ES6 Module（import|export）
    如何在浏览器中使用原生ES模块方案：在script标签上添加type="module"属性
    解决的实际问题：全局变量污染、函数命名冲突、依赖关系不好管理
    javascript模块化方案：
        命名空间模式：将需要定义的部分归属到一个对象的属性上
        闭包模块化模式：
        CommonJS：运行时加载，值的拷贝
            AMD：在主体运行前就已经加载并运行了所有模块
            CMD：运行到require才开始加载并运行其中的模块
        ES6 import：编译时加载，值的引用
    几个模块化方案对“循环引用”的处理有什么不同的表现：
            CommonJS 模块：返回的是当前己经执行的部分的值
            ES6 模块：变量不会被缓存，而是成为一个指向被加载模块的引用
    ES模块化导出的两种方式：export（为什么推荐这种）、export default
    ```
    * **执行机制 Event Loop**：
    ```
    为何try里面放return，finally还会执行，理解其内部机制：
        先执行finally，再执行return，若finally里有return则不执行try里的return
    JavaScript如何实现异步编程，可以详细描述EventLoop机制：挂起异步操作，执行同步任务（当一个任务执行结束后，当当前的微任务队列为空时，再去执行宏任务队列中的任务），执行异步任务
    宏任务和微任务分别有哪些：
        宏任务：new Promise、异步任务（setTimeout、setInterval）、click、渲染html文档
        微任务：promise.then、catch、finally、MutationObserver
    Node与浏览器EventLoop的差异：将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎
    如何在保证页面运行流畅的情况下处理海量数据：利用setTimeout将任务放入事件队列,等待js引擎空闲后被执行
    ```
* **ES6**：新版本JavaScript语言的标准
    ```
    ES6：类、模块化、箭头函数、函数参数默认值、模板字符串、解构赋值、延展操作符、对象属性简写、Promise、支持let与const
    ES7：Array.prototype.includes()、指数操作符
    ES8：async/await、Object.values()、Object.entries、String.prototype.padStart和String.prototype.padEnd、函数参数列表结尾允许逗号、Object.getOwnPropertyDescriptors()
    ```
    * **字符串、数组、对象扩展的API**：
    ```
    字符串：模板字符串、includes、startsWith|endsWidth、repeat、padStart|padEnd、trimStart|trimEnd、matchAll
    数组：扩展运算符、Array.from Array.of copyWithin find findIndex fill entries|keys|values includes flat|flatMap
        forEach(), filter(), reduce(), every() 和some()都会跳过空位
        map()会跳过空位，但会保留这个值
        join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串
    对象：属性的简洁表示法、属性名表达式、super 关键字、Object.keys()
    ```
    * **变量扩展：let、const，块级作用域，解构赋值**：
    ```
    1）块级作用域
    2）不存在变量提升
    3）暂时性死区：块级作用域内，声明的变量会绑定这个区域，声明变量之前不能使用该变量
    4）不允许重复声明（相同作用域内）
    5）const 声明的变量必须提供一个初始值，而且会被认为是常量（变量指向的内存地址不能改变）
    6）let、const、class 声明的全局变量不属于顶层对象（window/global）的属性
    ```
    * **函数扩展：箭头函数、默认参数、rest参数**：
    * **Symbol使用**：充当唯一的对象键、作为半私有属性键、避免名称冲突、通过Object.getOwnpropertySymbols()方法检索对象中的Symbol属性
    * **set和map数据结构：Set 内部实现**：
    ```
    Set（集合）：由一组无序且唯一的项组成的
        size、add(value)、delete(value)、has(value)、clear()、keys()、values()、entries()、forEach()
        WeakSet：成员只能是对象，其中的对象都是弱引用
    Map（字典）：用于存储数据，提供了“值—值”的对应
        size、set(key,value)、get(key)、delete(key)、has(key)、clear()、keys()、values()、entries()、forEach()
        WeakMap：只接受对象作为键名，键名所指向的对象不计入垃圾回收机制
    ```
    * **proxy对象属性代理器：属性的读取（get）和设置（set）相关操作**：
    ```
    get(target, propKey, receiver)
    set(target, propKey, value, receiver)
    ```
    * **迭代器和生成器函数，next和yield的理解**：
    ```
    迭代器（iterator）
    生成器（generator）
    ```
    * **Promise 原理：手写 Promise 实现**：
    ```
    使用Promise实现串行：
    ```
    * **异步编程的解决方案**：
    ```
    1）回调函数：回调地狱，不利于阅读
    2）Promise：使用.then方法解决了回调的问题，但代码依然冗余，且语义不强
    3）Generator：yield暂停执行，看起来非常像同步的写法，需要手动.next来执行下一个操作
    4）async：内置执行器，更好的语义（async代表异步，await代表等待），返回的是Promise
    如何处理循环的异步操作：
    ```
    * **class语法、构造函数的语法糖**：
    ```
    理解es6 class构造以及继承的底层实现原理

    静态方法：static function
    实例方法：function
    静态属性：Class.propname 或者 static propname = value
    实例属性：propname = value 或者 this.propname = value
    ```
* **React**：
    * **React和vue 选型和优缺点、核心架构的区别**：
    ```
    ```
    * **可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题**：
    ```
    React.createElement(component, props, ...children)：JSX是该方法的语法糖
    生命周期方法：constructor()、static getDerivedStateFromProps()、shouldComponentUpdate()、render()、componentDidMount()、getSnapshotBeforeUpdate()、componentDidUpdate()、componentWillUnmount()
        React16废弃：componentWillMount、componentWillReceiveProps、componentWillUpdate
    高阶组件（HOC）：参数为组件，返回值为新组件的纯函数
    refs：React.createRef()、回调 Refs、Refs 转发（React.forwardRef）
    render Props：
    Hook：在不编写 class 的情况下使用 state 以及其他的 React 特性（无状态组件变成函数组件）
        useState：在函数组件中添加 state
        useEffect：在函数组件中执行副作用操作（componentDidMount、componentDidUpdate、componentWillUnmount）
        规则：只在最顶层使用 Hook、只在 React 函数中调用 Hook
        自定义Hook：将组件逻辑提取到可重用的函数中
    ```
    * **React中setState的执行机制，如何有效的管理状态**：
    ```
    形式：setState(object|function,[callback])
    setState基本特点：
        setState是同步执行的
        setState在React生命周期和合成事件中批量覆盖执行，但是多次连续使用函数式的setState，React本身会进行一个递归传递调用，将上一次函数执行后的state传给下一个函数
        setState在原生事件，setTimeout，setInterval，Promise等异步操作中，state会同步更新
    state中应该只保存与渲染有关的状态
    ```
    * **React事件机制**：
    ```
    React为什么要自己实现一个事件系统：性能优化（事件委托，对象池，批量更新）、复用（跨浏览器兼容，跨平台兼容）
    React的事件系统是怎么运作起来的：将事件监听挂载在document上，并且构造合成事件，并且在内部模拟了一套捕获和冒泡并触发回调函数的机制，实现了自己一套事件系统
    ```
    * **React的虚拟DOM的内部实现：virtual dom 有哪些好处**：
    ```
    为何使用虚拟DOM：提高开发效率，在重复渲染时它帮助我们计算如何更高效的更新，跨浏览器兼容，跨平台兼容
    Babel将JSX转换成createElement，createElement函数对props和传入的孩子节点进行处理，构造成一个ReactElement对象（虚拟DOM），ReactDOM.render将生成好的虚拟DOM渲染到指定容器上
    ```
    * **Diff算法的内部实现：diff的bug**：
    ```
    传统diff算法：通过循环递归对节点进行依次对比，效率低下，算法复杂度O(n^3)
    React diff：复杂度O(n)
    启发式算法：
        两个不同类型的元素会产生出不同的树；
        开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；
    diff 策略：
        tree diff：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计
        component diff：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构
        element diff：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分
            不同key会销毁和重建，相同key会更新
            遍历新集合，判断老集合中是否存在相同的节点，插入新节点，当前节点在老集合中位置小于新集合时移动，遍历老集合删除不存在节点
    列表使用 index 做 key，删除其中一个后，如何表现：更新前面节点，删除最后一个节点（id做key：删除不存在节点）
    将最后一个节点移动到列表首部：移动除首部之外的所有节点
    ```
    * **React的Fiber工作原理，解决了什么问题**：
    ```
    问题：渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验
        React16 用了分片的方式解决问题（异步渲染）。就是把一个任务分成很多小片，当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务，有就做这个新任务，没有就继续做原来的任务
    Fiber：实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务
        实现方式是使用了浏览器的requestIdleCallback这一 API
    ```
    * **React Router的底层实现原理、动态加载实现原理**：
    ```
    ```
    * **基于React的特性和原理，可以手动实现一个简单的React**：
    ```
    ```
    * **熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理，函数式编程关系**：
    ```
    ```
* **Vue**：
    * **基本指令**：
    ```
    ```
    * **实例的属性和方法**：
    ```
    ```
    * **实例的生命周期**：
    ```
    ```
    * **组件基础：创建、注册、添加属性方法、套用等**：
    ```
    ```
    * **vue 组件间通信，父子、兄弟、跨级**：
    ```
    ```
    * **插槽slot等**：
    ```
    ```
    * **熟练使用Vue的API、生命周期、钩子函数**：
    ```
    ```
    * **Vue Router的底层实现原理、动态加载实现原理**：
    ```
    ```
    * **MVVM框架设计理念**：
    ```
    ```
    * **Vue双向绑定实现原理、Diff算法的内部实现**：
    ```
    MVVM双向数据绑定：Object.definePrototype()监控对象的属性（可配置、可枚举、数据描述符：value|writable、存取描述符：get|set）
    ```
    * **Vue的事件机制**：
    ```
    通过编译模板，解析出事件指令，将事件和事件回调附加到 vnode tree上，
    在 patch过程中的创建阶段和更新阶段都会对这个 vnode tree进行处理，
    拿到每个 vnode上附加的事件信息，就可以调用原生 DOM API对相应事件进行注册或移除
    ```
    * **vue 的 nextTick 实现原理以及应用场景**：
    ```
    ```
    * **从template转换成真实DOM的实现机制**：
    ```
    ```
    * **熟练使用Vuex管理数据流，并理解其实现原理**：
    ```
    ```
    * **Vue3 proxy 解决了哪些问题，优劣**：
    ```
    1）Object.defineProperty的性能开销
    2）defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历,proxy能劫持一个完整的对象
    3）能够监听添加删除属性事件
    4）新版本将这个模块耦合到了vue里面，可以单独作为一个库来使用
    劣：
    1）只会关注浅层数据
    ```
    * **发布订阅模式和观察者模式的异同**：
    ```
    ```
    * **vue-cli**：
    ```
    ```
* **性能优化**：
    * [JavaScript](https://segmentfault.com/a/1190000000490324)
    * [DOM操作](https://segmentfault.com/a/1190000000490322)
    * [小知识](https://segmentfault.com/a/1190000002588062)
    ```
    v8引擎内存优化：
        垃圾回收算法：新生代复制（空间换时间），老生代标记删除整理（时间换空间）
        node查看内存使用情况：process.memoryUsage()
    前端查询：http请求的数量、合适的加载策略（懒加载|预加载）、合适的缓存机制
    ```
    * **quicklink fcp fmp**：
    ```
    ```
    * **衡量指标window.performance.timing**：
    ```
    ```
    * **js文件摆放顺序、减少请求、雪碧图**：
    ```
    ```
    * **工作中做过的一些性能优化处理**：
    ```
    代码调优：
        优化cpu占用率
        时间复杂度越大，cpu执行时间越长
        for循环递减优于递增（计算机编译出来的指令少）
        重绘重排：
            函数中多次用到的全局变量，保存在局部变量中：查找window下面很多属性中的一个较慢，查找原型链层次过多会慢
            使用事件代理/事件委托：函数会占用空间
            批量修改DOM：减少重绘重排次数，读取DOM也会导致重绘
    加载资源调优：
        路由懒加载：const Com = ()=>import("../a/Com")
        组件异步加载：
            Com:function(resolve){require(["../a/Com"],resolve)}
            Com:()=>import("../a/Com")
        高级异步组件：加载过程处理
            component:import("../a/Com"),
            loading:Loading,
            delay:200,
            timeout:2000,
            error:ErrorDom,
    ```
    * **服务端渲染：SSR实现方案、优缺点、及其性能优化**：
    ```
    ```
    * **了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案**：
    ```
    ```
    * **了解常见的Web、App性能优化方案**：
    ```
    ```
    * **SEO排名规则、SEO优化方案、前后端分离的SEO**：
    ```
    ```
    * **Webpack的性能优化方案**：
    ```
    ```
    * **Canvas性能优化方案**：
    ```
    ```
    * **React、Vue等框架使用性能优化方案**：
    ```
    ```
* **Webpack**：
    ```
    配置：
        原理：compiler和compilation是核心原理
            plugins的实现原理
            loaders的实现原理
        优化：图片压缩，图片合并雪碧图，图片转base64，css js编译、合并、分割、压缩，提取公共代码，Tree shake自动删除无用代码
        webpack如何优化编译速度
        webpack 热更新原理
        webpack+ci
    ```

```
web：
    跨域：
    本地存储：
    浏览器渲染原理：
    Ajax的原生写法
    深浅拷贝原理：包含function
    项目工程：
CSS：
    浏览器兼容性写法
    盒模型在不同浏览器的差异
    CSS选择器（三大特性）
    css权重：CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则
    CSS伪类和伪元素有哪些，它们的区别和实际应用
    水平垂直居中的方案、可以实现6种以上并对比它们的优缺点
    BFC机制，BFC实现原理，可以解决的问题，如何创建BFC
    css清除浮动
    css和js动画
    Sass、Less的异同，以及使用配置
    CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染
    熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等
    掌握一套完整的响应式布局方案
    屏幕适配以及页面自适应：理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用
    css 预处理器机制
    CSS3中新增的选择器
    CSS3中新增的属性，transform、trasition、animation等
    百分比布局：px单位用%num代替，占父级元素的百分比
    flex弹性布局：主轴、辅助轴的几个属性
    grid栅格布局：使用框架中的类名来替代，本质上还是百分比布局

html：
    语义化标签的理解：
    结构化的理解：
    简洁的html结构：
    h5中新增的属性：自定义属性data、类名className等；新增表单元素；拖拽Drag
    h5中新增的API、修改的API、废弃的API稍作了解（离线存储、audio、video）

javascript
    基本数据类型：
        Symbol类型的应用（手动实现Symbol）
        堆栈
        判断数据类型：区别和联系
            typeof：
            instanceof：检查某个对象是不是另一个对象的实例
            Object.prototype.toString：
            constructor：
            toString.call(数据)：[object 数据类型]
        可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用
        出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字
    字符串、数组、对象常用API
    类数组转换成数组
    原型继承：
        理解原型设计模式以及JavaScript中的原型规则
        instanceof的底层实现原理，手动实现instanceof
        有几种方式可以实现继承，用原型实现继承有什么缺点，怎么解决
        可以描述new一个对象的详细过程，手动实现一个new操作符
        理解es6 class构造以及继承的底层实现原理
    作用域闭包：
        理解词法作用域和动态作用域
        理解JavaScript的作用域和作用域链
        this：
            全局环境下this：
            箭头函数的this：
            构造函数的this：
            总结this指向：谁调用它，this就指向谁
        闭包的实现原理和作用，可以列举几个开发中闭包的实际应用
        理解堆栈溢出和内存泄漏的原理，如何防止
        如何处理循环的异步操作
        模块化：
            如何在浏览器中使用原生ES模块方案：在script标签上添加type="module"属性
            对javascript模块化发展的看法
            理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理
            几个模块化方案对“循环引用”的处理有什么不同的表现
            ES模块化导出的两种方式：export（为什么推荐这种）、export default
            AMD、CMD
    执行机制 Event Loop：
        为何try里面放return，finally还会执行，理解其内部机制
        JavaScript如何实现异步编程，可以详细描述EventLoop机制
        宏任务和微任务分别有哪些
        Node与浏览器EventLoop的差异
        如何在保证页面运行流畅的情况下处理海量数据

es6：
    ES6提出的真正趋势
    字符串、数组、对象扩展的api
    变量扩展：let、const解构赋值，块级作用域
    函数扩展：箭头函数默认参数、rest参数
    展开运算符、模板字符串
    set和map数据结构：Set 内部实现
    迭代器和生成器函数next和yield的理解
    proxy对象属性代理器：属性的读取（get）和设置（set）相关操作
    Promise 原理：手写 Promise 实现，异步编程的解决方案
    Async/Await 原理：异步编程的终极方案promise + generator的语法糖
    class语法、构造函数的语法糖
    模块化编程export + import的导出和导入

react：
    React和vue 选型和优缺点、核心架构的区别
    可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题
    React key：列表使用 index 做 key，删除其中一个后，如何表现
    React中setState的执行机制，如何有效的管理状态
    React的事件底层实现机制
    React的虚拟DOM的内部实现：virtual dom 有哪些好处
    Diff算法的内部实现：diff的bug
    React的Fiber工作原理，解决了什么问题
    React Router和Vue Router的底层实现原理、动态加载实现原理
    基于React的特性和原理，可以手动实现一个简单的React
    熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理

vue：
    基本指令
    实例的属性和方法
    实例的生命周期
    组件基础：创建、注册、添加属性方法、套用等
    vue 组件间通信，父子、兄弟、跨级
    插槽slot等
    熟练使用Vue的API、生命周期、钩子函数
    MVVM框架设计理念
    Vue双向绑定实现原理、Diff算法的内部实现
    Vue的事件机制
    vue 的 nextTick 实现原理以及应用场景
    从template转换成真实DOM的实现机制
    熟练使用Vuex管理数据流，并理解其实现原理
    Vue3 proxy 解决了哪些问题，优劣
    发布订阅模式和观察者模式的异同
    vue-cli

性能优化：
    quicklink fcp fmp
    衡量指标window.performance.timing
    js文件摆放顺序、减少请求、雪碧图
    工作中做过的一些性能优化处理
    服务端渲染：SSR实现方案、优缺点、及其性能优化
    了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案
    了解常见的Web、App性能优化方案
    SEO排名规则、SEO优化方案、前后端分离的SEO
    Webpack的性能优化方案
    Canvas性能优化方案
    React、Vue等框架使用性能优化方案

```
```
// [制作在线简历](https://juejin.im/post/5c0d2622e51d4529ee234272)
天壤智能、猫眼电影、米哈游、bilibili、阅文、达达京东到家、达观数据
```

