## 知识扩展

* [图片懒加载](#图片懒加载)
* [服务端渲染（SSR）、客户端渲染（CSR）](#服务端渲染（SSR）、客户端渲染（CSR）)
* [MVC MVVM](#MVC MVVM)
* [跨域/代理](#跨域/代理)
* [前端优化](#前端优化)
* [WebSocket](#WebSocket)
* [圣杯模式：继承](#圣杯模式：继承)
* [客户端存储](#客户端存储)

* CDN：内容分发网络
* SDK：软件开发工具包
* DNS：域名系统-根据域名查出IP地址
* v8：Google开发的开源JavaScript引擎
* webRTC：一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点的连接，实现视频流或音频流或者其他任意数据的传输
* requestAnimationFrame：按帧对网页进行重绘]
* 语法糖：对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会
* IIFE：立即执行函数表达式
* SEO（搜索引擎）优化：是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式


#### 图片懒加载
```
懒加载是一种对网页性能优化的方式，它的原理是优先加载在可视区域内的图片，而不一次性加载所有图片。
当浏览器滚动，图片进入可视区时再去加载图片。通过设置图片的 src 属性来让浏览器发起图片的请求。
当这个属性为空或者没有时，就不会发送请求。
//可视
1、元素距离顶部高度 < document.documentElement.scrollTop + document.documentElement.clientHeight;
2、IntersectionObserver (http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)
```
#### 服务端渲染（SSR）、客户端渲染（CSR）
```
服务端渲染优点：
1、解决渲染白屏，提高用户第一次访问网站的感知性能
2、解决单页面应用（SPA）的 SEO
服务端渲染框架：Next.js
客户端渲染优点：
1、网络传输数据量小、减少了服务器压力
2、前后端分离
3、局部刷新，交互好可实现各种效果
```
#### MVC MVP MVVM
```
MVC：
    模型：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)
    视图：界面设计人员进行图形界面设计
    控制器：负责转发请求，对请求进行处理
MVP：
    模型：
    视图：
    Presenter：
MVVM：
    模型：模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）
    视图：就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）
    视图模型：视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信
    绑定器：声明性数据和命令绑定隐含在MVVM模式中。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图
```
#### 跨域/代理
```
同源策略："协议+域名+端口"三者相同
允许跨域加载资源：<img src=XXX>、<link href=XXX>、<script src=XXX>、<iframe src=XXX>
//关闭同源策略：chrome.exe
jsonp：使用<script>元素作为Ajax传输的技术称为JSONP，利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数，JSONP请求一定需要对方的服务器做支持才可以（响应数据是经过JSON编码的）
cors：服务器设置HTTP响应头中Access-Control-Allow-Origin的值，解除跨域限制
iframe：postMessage传递数据、window.name 传值、location.hash 传值、设置document.domain（只能用于二级域名相同的情况下）
websocket：允许跨域通讯
Node 中间件：代理服务器
nginx：高性能的HTTP和反向代理服务器，可以顺便修改 cookie 信息
proxy：webpack配置代理
```
#### 前端优化
```
[JavaScript](https://segmentfault.com/a/1190000000490324)
[DOM操作](https://segmentfault.com/a/1190000000490322)
[小知识](https://segmentfault.com/a/1190000002588062)
```
#### WebSocket
* [文档](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)
* [文档](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
* Service Workers：（代替离线缓存Application Cache）离线体验、后台同步、推送通知。
* Web Workers：为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
```
一种网络通信协议，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
WebSocket：数据格式比较轻量，性能开销小，通信高效。可以发送文本和二进制数据。没有同源限制。
ajax轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。
long poll：采取的是阻塞模型。客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
```
```js
//客户端
const ws = new WebSocket("ws://localhost:8080");//测试（wss://echo.websocket.org）
ws.onopen = function(evt) {
    console.log("Connection open ...");
    ws.send(JSON.stringify({a:"00000000"}));
};
ws.onmessage = function(evt) {
    console.log( "Received Message: " + evt.data);
};
ws.onclose = function(evt) {
    console.log("Connection closed.");
};
//node服务端
const WebSocketServer = require('ws').Server, wss = new WebSocketServer({port: 8080});
// 连接池
let clients = [];
wss.on('connection', function(ws) {
    // 将该连接加入连接池
    clients.push(ws);
    ws.on('message', function(message) {
        // 向其他人推送消息
        clients.forEach(function(ws1){
            if(ws1 !== ws) {
                ws1.send(message);
            }
        })
    });
    ws.on('close', function(message) {
        // 连接关闭时，将其移出连接池
        clients = clients.filter(function(ws1){
            return ws1 !== ws
        })
    });
});
```
#### 圣杯模式：继承
```
var inherit = (function () {
    var Buffer = function () {};
    return function (Target, Origin) {
        Buffer.prototype = Origin.prototype;
        Target.prototype = new Buffer();
        Target.prototype.constructor = Target;
        Target.prototype.uber = Origin;
    }
})();

A.prototype.a = "1";
function A() {
    this.a = "0";
}
B.prototype.a = "2";
function B() {

}
C.prototype.a = "3";
function C() {

}
//圣杯模式
inherit(B, A);
var b = new B();

C.prototype = A.prototype;
var c = new C();

C.prototype = new A();
var d = new C();
```
#### 客户端存储
```
cookie（4KB）：服务端脚本可以读写存储在客户端的cookie值，（有效期：默认-浏览器进程关闭之前，max-age设置有效期时长秒，作用域：默认-同目录或其子目录，path指定路径前缀，domain指定域）
Web存储（5MB、2.5MB）：localStorage（有效期：永久性，作用域：同浏览器同源文档共享）、sessionStorage（有效期：浏览器页面关闭之前-可恢复，作用域：顶级窗口共享）
应用程序存储：AppCache：“本地安装”程序运行所需的所有文件，同步机制自动更新缓存最新数据
Servers Work:
客户端数据库：IndexedDB：对象数据库（同源页面共享）
```
